#!/usr/bin/env python3

import sys
import numpy as np
from mpi4py import MPI
from scipy.signal import decimate

def mpi_log_print(out, pre=0, msg='empty message', file= sys.stdout, flush=True):
    if out:
        print('\t'*pre + msg, file= file, flush=flush)

class rotate:
    def __init__(self, fnm, para, lognm = '', exclude_sta = set() ):
        """
        fnm: Filename of the *.log generated by `wc -l *` that is described in README.
        exclude_sta: stations to be excluded.
        """
        self.comm = MPI.COMM_WORLD
        self.mpi_size = self.comm.Get_size()
        self.rank     = self.comm.Get_rank()
        self.mpi_log = open('%s_%03d.log' % (lognm, self.rank), 'w' )
        #
        self.fnm = fnm
        self.exclude_sta = exclude_sta
        #
        self.vol = dict()
        self.rd()
        #
        self.prepare_mpi_job()
        #
        self.para= para
        self.para.run(set(self.proc_sta) )
    def rd(self):
        """
        Read data and organize data.
        """
        mpi_log_print(True, 0, '# Input data from %s ...' % self.fnm, file=self.mpi_log, flush=True )
        mpi_log_print(True, 1, 'ignore stations: %s' % (', '.join(list(self.exclude_sta))) , file=self.mpi_log, flush=True )
        for line in open(self.fnm):
            n_sample, data_fnm = line.strip().split()
            n_sample = int(n_sample)
            sta, day, tmp = data_fnm.split('/')[-3:]
            if sta in self.exclude_sta:
                continue # get rid of excluded stations
            dat, com = tmp.split('.')
            if sta not in self.vol:
                self.vol[sta] = dict()
            if com not in self.vol[sta]:
                self.vol[sta][com] = dict()
            self.vol[sta][com][day] = {'size': n_sample, 'nm': dat}
            self.rootdir = '/'+'/'.join( open(self.fnm).readline().split()[1].split('/')[:-3] ) + '/'
    def prepare_mpi_job(self):
        """
        """
        nsta = len( self.vol.keys() )
        chunk = int(np.ceil(nsta/self.mpi_size) )
        i_start, i_end = chunk*self.rank, chunk*(self.rank+1)
        if i_end > nsta:
            i_end = nsta
        sta_lst = sorted(list(self.vol.keys() ) )
        self.proc_sta = sta_lst[i_start: i_end]
        mpi_log_print(True, 0, '# Init mpi job. This node takes care of stations: [%d->%d) (%d/%d)' % (i_start, i_end, len(self.proc_sta ), nsta) , file=self.mpi_log, flush=False)
        mpi_log_print(True, 1, '%s' % ', '.join(self.proc_sta) , file=self.mpi_log, flush=True)
    def rotate(self, ascii_prename, out_prename, cut_head=1, cut_end=1):
        mpi_log_print(True, 0, '# Processing...', file=self.mpi_log, flush=True)
        nsta = len(self.proc_sta )
        for ista, sta in enumerate(self.proc_sta):
            #####
            declination_degree= self.para.get_value(sta, 'rotation_angle_wrt_north_dec')
            resampling_rate_hz= 1 
            gainB=1.0
            bz_adjustment=2.2
            gainE=1.0
            gainEonly = 10.0
            xlength = self.para.get_value(sta, 'Ex_NS_electrode_dipole_length_m')
            ylength = self.para.get_value(sta, 'Ey_EW_electrode_dipole_length_m')
            #####
            tmp = '%s/merged-%s-cut_%03d_%03d' % (ascii_prename, sta, cut_head, cut_head)
            tmp = tmp.replace('02', '03').replace('data', 'data_bin')
            BX_filename = tmp + '.BX.bin'
            BY_filename = tmp + '.BY.bin'
            BZ_filename = tmp + '.BZ.bin'
            EX_filename = tmp + '.EX.bin'
            EY_filename = tmp + '.EY.bin'
            #####
            tmp2 = '%s/merged-%s-cut_%03d_%03d' % (out_prename, sta, cut_head, cut_head)
            tmp2 = tmp2.replace('02', '04') 
            out_BX_filename = tmp2 + '.BX.bin'
            out_BY_filename = tmp2 + '.BY.bin'
            out_BZ_filename = tmp2 + '.BZ.bin'
            out_EX_filename = tmp2 + '.EX.bin'
            out_EY_filename = tmp2 + '.EY.bin'
            #####
            mpi_log_print(True, 1, '(%d/%d), %s' % (ista+1, nsta, tmp), file = self.mpi_log, flush=False )
            mpi_log_print(True, 1, '    ==> %s'    % (tmp2              ), file = self.mpi_log, flush=False )
            mpi_log_print(True, 1, '    declination_degree: %f' % (declination_degree), file = self.mpi_log, flush=False )
            mpi_log_print(True, 1, '    resampling_rate_hz: %f' % (resampling_rate_hz), file = self.mpi_log, flush=False )
            mpi_log_print(True, 1, '    gainB             : %f' % (gainB             ), file = self.mpi_log, flush=False )
            mpi_log_print(True, 1, '    bz_adjustment     : %f' % (bz_adjustment     ), file = self.mpi_log, flush=False )
            mpi_log_print(True, 1, '    gainE             : %f' % (gainE             ), file = self.mpi_log, flush=False )
            mpi_log_print(True, 1, '    gainEonly         : %f' % (gainEonly         ), file = self.mpi_log, flush=False )
            mpi_log_print(True, 1, '    xlength           : %f' % (xlength           ), file = self.mpi_log, flush=False )
            mpi_log_print(True, 1, '    ylength           : %f' % (ylength           ), file = self.mpi_log, flush=True  )
            #####
            #continue
            #######
            ## rotate BX BY
            ####
            mpi_log_print(True, 2, 'processing BX, BY, BZ:...', file=self.mpi_log, flush=False )
            mpi_log_print(True, 2, '%s' % (BX_filename), file=self.mpi_log, flush=False )
            mpi_log_print(True, 2, '%s' % (BY_filename), file=self.mpi_log, flush=False )
            mpi_log_print(True, 2, '%s' % (BZ_filename), file=self.mpi_log, flush=True )
            bx = np.fromfile(BX_filename, dtype='float32')
            by = np.fromfile(BY_filename, dtype='float32')
            bz = np.fromfile(BZ_filename, dtype='float32')
            meanBx = np.mean(bx[5000:] ) # hard-coded 5000 from the 
            meanBy = np.mean(by[5000:] ) # matlab script by Bruce.
            # use complex number to determine angle
            z = np.complex(meanBx, meanBy)
            # the rotation angle is defined as counter-clockwise positive, contrary to
            # the geomagnetic declination
            RotAngleB = np.angle(z)
            RotAngleB = RotAngleB - declination_degree/180.0*np.pi
            # Apply angle to each entry in the horizontal magnetic fields
            new_bx = bx*np.cos(RotAngleB) + by*np.sin(RotAngleB)
            new_by = by*np.cos(RotAngleB) - bx*np.sin(RotAngleB)
            ####
            ## Convert voltages of magnetic field into nanoTesla for bx and by
            ####
            # the values are given in microvolts with the bartington sensors having a
            # maximum output of 10V equivalent to 70000nT, plus taking the gain (see
            # gainB and gainE) into consideration
            # Furthermore the data will be downsampled to 1 second due to sensitivity
            # of the Bartington sensor and to reduce the filesize 
            resample_factor = int(10/resampling_rate_hz)
            #bz_adjustment = 2.2; # to fix large Bz values outside the voltage range (a fix by Jingming Duan of GA)
            new_bx = decimate(new_bx, resample_factor) /10**7 * 70000 * gainB 
            new_by = decimate(new_by, resample_factor) /10**7 * 70000 * gainB 
            new_bz = decimate(    bz, resample_factor) /10**7 * 70000 * gainB * bz_adjustment # z-component
            ####
            ## rotate EX and EY
            ####
            mpi_log_print(True, 2, 'processing EX, EY:...', file=self.mpi_log, flush=False )
            mpi_log_print(True, 2, '%s' % (EX_filename), file=self.mpi_log, flush=False )
            mpi_log_print(True, 2, '%s' % (EY_filename), file=self.mpi_log, flush=True )
            ex = np.fromfile(EX_filename, dtype='float32')
            ey = np.fromfile(EY_filename, dtype='float32')
            new_ex = decimate(ex, resample_factor)/xlength * gainE / gainEonly
            new_ey = decimate(ey, resample_factor)/ylength * gainE / gainEonly
            ####
            #   output to files
            ####
            for ofnm, vec in zip(
                        [out_BX_filename, out_BY_filename, out_BZ_filename, out_EX_filename, out_EY_filename],
                        [new_bx, new_by, new_bz, new_ex, new_ey] ):      
                vec.astype('float32').tofile(ofnm)

class parameter_set:
    def __init__(self, key_fnm = '00_raw_ASCII_new/WA_and_SA_metadata/WA/auslamp_metadata_template.txt',
                    sta_fnm_template = '00_raw_ASCII_new/WA_and_SA_metadata/WA/%s.txt'):
        self.key_fnm = key_fnm
        self.sta_template= sta_fnm_template
        self.keys = [it.split('=')[0] for it in open(self.key_fnm, 'r')]
        self.vol =dict()
    def run(self, sta_set):
        self.sta_set = sta_set
        for sta in self.sta_set:
            if sta not in self.vol:
                self.vol[sta] = dict()
            fnm = self.sta_template % (sta)
            for k, v in zip(self.keys, open(fnm, 'r') ):
                k = k.strip()
                #print(k, v)
                self.vol[sta][k] = v
    def get_value(self, sta, key):
        """
        Return the raw string of the value
        """
        try:
            v = self.vol[sta][key]
            return float(v)
        except:
            mpi_log_print(True, 0, 'Warning: cannot get values. Use 1.0 instead. %s %s ' % (sta, key), file=sys.stderr, flush=True )
            return 1.0
            


if __name__ == "__main__":
    WA_sta_exclude_set = set( (
        'WA11','WA12','WA28', 'WASA352', # different machine
        'WA26', 'WASA302' # warnings reported by 01_check.py
    ) )

    SA_sta_exclude_set = set( (
            'SA246', 'SA299', 'SA351', 'SA320-2', 'SA227', 'SA347', 'SA247', 
            'SA250', 'SA324-2', 'SA326S', 'SA277', 'SA344-2'
        ) )
    ######### WA
    para = parameter_set(key_fnm = '00_raw_ASCII_new/WA_and_SA_metadata/WA/auslamp_metadata_template.txt',
                    sta_fnm_template = '00_raw_ASCII_new/WA_and_SA_metadata/WA/%s.txt')
    app = rotate('01_workspace/WA.log', para, '04_workspace/WA_rotate_', WA_sta_exclude_set)
    app.rotate('02_workspace/merged_data_WA/', '04_workspace/rotated_data_bin_WA/', 1, 1)
    ######### SA
    para = parameter_set(key_fnm = '00_raw_ASCII_new/WA_and_SA_metadata/SA/auslamp_metadata_template.txt',
                    sta_fnm_template = '00_raw_ASCII_new/WA_and_SA_metadata/SA/%s.txt')
    app = rotate('01_workspace/SA.log', para, '04_workspace/SA_rotate_', SA_sta_exclude_set)
    app.rotate('02_workspace/merged_data_SA/', '04_workspace/rotated_data_bin_SA/', 1, 1)
